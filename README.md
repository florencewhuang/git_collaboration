**Both merges above are fast-forward merges. Explain**: In a fast forward merge you will only see one path. The branches will not diverge because the main branch just needs to catch up to changes made in other branches, but no changes were made in the main branch. 
**In your own words, write down a scenario that will involve a merge conflict between develop and conflict_branch**: Changing titles in both branches without pulling any previous changes can create merge conflicts when trying to push separate changes. 
**In your own words, write down a scenario that will NOT involve a merge conflict between develop and conflict_branch despite some change on the same file on both branches.**: There would not be a merge conflict if we push and pull between each change on the file. Additionally if you make changes in two different places then when merging it together there won't be a conflict, but to ensure no conflict, it is good practice to not make to many changes at once that are uncommited/ uncommunicated. In our example, when branching out (branch_1), we ensured that develop was updated. Then if we had to make any changes to develop, those changes (merging a branch with an addtional paragraph tag) were discussed between teams before doing the merge to ensure there were no conflicts in the changes when branch_1 merges into develop. Communication is a critical way to decerease the likehood of merge conflicts. 
![image](https://github.com/florencewhuang/git_collaboration/assets/114940826/a2048d1f-b920-4217-ad05-0cb91a49b534)
*Note: our no_conflict branch is the branch_1 code, the final merge in the image is the true no-conflict merge.
